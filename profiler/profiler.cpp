// profiler.cpp
// Gregory Rosenblatt
// 5/11/05

#include "profiler/profiler.h"
#include "util/timer.h"
#include "pooledmap.h"
using namespace std;
using namespace boost;

#define ROOT_PROFILE_NAME	"Root"

// profiler database
namespace Starscape {

	namespace Profiler {

		// maps complete profile names to profile histories
		typedef PooledMap<PooledString, ProfileHistory>::Type	ProfileMap;
		
		// profiling database internal data
		ProfileMap		profileMap;
		ProfileList		profileResultList;
		ProfileHistory*	rootProfile = 0;
		ProfileHistory*	currentProfile = rootProfile;	// stores current "topmost" profile

		// This class is not intended for use anywhere else!
		// This class uses a static instance of itself to force the root profile to
		// contain the profile history of the entire program execution, and ensure
		// a unique root.  Otherwise it's possible to accidentally create many
		// different profiling trees with several roots that will be inaccessible
		// while trying to generate results.
		class CompleteRuntimeProfile {
			// constructor and destructor will automatically manage the profile
			// sampling time
			CompleteRuntimeProfile() : sample_(ROOT_PROFILE_NAME) {}
			// singleton instance
			static CompleteRuntimeProfile	runtimeProfile;
			ProfileSample	sample_;	// sample lives as long as program execution
		};

		// initialize static data
		CompleteRuntimeProfile CompleteRuntimeProfile::runtimeProfile;

		// pre-declaration
		void AddToResults(ProfileHistory&, unsigned int);

		// function redirector that takes a ProfileHistory* as the first parameter
		// and uses it to call AddToResults()
		// this exists for compatibility with standard algorithms
		void AddItrToResults(ProfileHistory* pprof, unsigned int level) {
			assert(pprof!=0);
			AddToResults(*pprof, level);
		}
		
		// recursively adds a profiling entry and its children to an output list
		// and assigns each entry its scope level information
		void AddToResults(ProfileHistory& profile, unsigned int level) {
			profile.SetLevel(level);
			profileResultList.push_back(&profile);
			for_each(profile.GetChildListBegin(), profile.GetChildListEnd()
					,boost::bind2nd(boost::ptr_fun(AddItrToResults), level+1));
		}

		// triggers the recursive creation of an output list of profiling histories
		void GenerateResultsList() {
			assert(rootProfile!=0);
			profileResultList.clear();
			AddToResults(*rootProfile, 0);
			profileResultList.pop_front();
		}

		// returns the list of profile histories generated by GenerateResultsList()
		ProfileList& GetResultsList() {
			return profileResultList;
		}

		// resets all of the profiling database's internal data
		void Reset() {
			assert(rootProfile!=0);
			rootProfile->Reset();
			profileMap.clear();
			profileResultList.clear();
			currentProfile = rootProfile;
		}

		// A timing function for internal use with ProfileSample
		unsigned int GetTime() {
			return TotalTime();
		}

		// retrieves the current scope's complete name
		const char* GetCurrentName() {
			if (currentProfile==0)
				return "";
			return currentProfile->GetName();
		}

		// returns the name of a profiling entry that includes
		// its scope information
		PooledString BuildCompleteName(const char* name) {
			PooledString completeName(GetCurrentName());
			// appends the new name to the current scope name
			completeName+="::";
			completeName+=name;
			return completeName;
		}

		// giving the behavior of a stack, it sets the topmost profile
		// by its mapped name
		ProfileHistory& PushCurrentProfile(const char* name) {
			PooledString fullname = BuildCompleteName(name);
			// retrieves the profile by name if it exists,
			// otherwise the map creates it automatically
			ProfileHistory& profile = profileMap[fullname];
			// this basically is a check to see if the profile
			// was in fact just created by the map
			// (it won't have a parent)
			if (!profile.HasParent()) {
				profile.SetName(fullname.c_str());
				// if this isn't the first profile to be made
				// then set the parent of this profile to be
				// the one currently on the stack
				if (currentProfile!=0)
					profile.AddToParent(*currentProfile);
				// otherwise it is the first profile, and is
				// designated as the root
				else
					rootProfile = &profile;
			}
			currentProfile = &profile;
			return profile;
		}

		// giving the behavior of a stack, it sets the topmost profile
		// to the current profile's parent
		void PopCurrentProfile() {
			assert(currentProfile!=0);
			currentProfile = currentProfile->GetParentPtr();
		}
	} // Profiler
} // Starscape

using namespace Starscape::Profiler;

// pushes this profiling sample's corresponding profile entry onto
// the stack and starts the sample timer.
ProfileSample::ProfileSample(const char* name)
 : profile_(Profiler::PushCurrentProfile(name)), startTime_(Profiler::GetTime())
{}

// pops the current profile off of the stack after this sample adds
// its TotalTime() to it
ProfileSample::~ProfileSample() {
	profile_.AddSample(TotalTime());
	Profiler::PopCurrentProfile();
}

// the total time this sample existed for
unsigned int ProfileSample::TotalTime() const {
	return Profiler::GetTime()-startTime_;
}
